## 17-2) 포인터의 필요성은 어디에서 찾아야 하는가?
- [[Data Structure|자료 구조]]를 공부하면 포인터의 필요성을 보다 확실히 느낄 수 있다.
- 일단은 포인터에 대해서 열심히 공부하고, 포인터가 가져다 주는 이점은 앞으로 천천히 생각해 보기로 하자.

# 18. 다차원 배열 그리고 포인터
- 포인터의 마지막 난관.

## 18-1) 2차원 배열 이름의 포인터 타입
- 함수로 전달되는 배열의 이름은 포인터로 받을 수 있다고 배웠다.
	- 예를 들어, `int arr[5]`는 `int *`로 받는다.
	- 배열의 이름 자체가 배열의 타입과 동일한 타입의 **포인터 상수**이기 때문에 가능한 일이었다.
- 그러면 *"2차원 배열의 이름은 더블 포인터로 받으면 되겠네"*라고 쉽게 결론 내릴 수도 있지만, 잘못된 생각이다.
	- 2차원 배열 이름의 포인터 타입은 무조건 더블 포인터라고 할 수 없다.
### 1) 2차원 배열의 이름이 가리키는 것은?
- 1차원 배열에서는 배열 이름이 가리키는 요소가 배열 이름의 포인터 타입을 결정짓는 기준이었다.
- 2차원 배열에서도 마찬가지로 배열 이름이 가리키는 요소가 배열 이름의 포인터 타입을 결정짓는 기준의 일부가 된다.
	[[two_array1#Source Code]]
	[[two_array1#Execution Report]]
	- 위 예제에서는 `a[0]`,  `a[1]`, `a[2]`가 나타내는 값을 출력하고 있다. 
		- 여기서, 출력되는 값의 차이가 $8$임을 알 수 있다.
		- 또한, 배열 이름 `a`가 가리키는 곳과 `a[0]`이 가리키는 곳이 같음도 알 수 있다.
	- `a[0]`은 배열 요소 `a[0][0]`을 가리키고, `a[1]`은 배열 요소 `a[1][0]`을 가리키며, 마지막으로 `a[2]`는 배열 요소 `a[2][0]`을 가리킨다.
		- 이를 2차원적인 메모리 구조로 이야기한다면, 각 행의 첫 번째 요소를 가리킨다고 말할 수 있다.
	- 이제 배열 이름 `a`의 포인터 타입에 대해 이야기 해보자.
		- 쉽게 생각해서, a가 가리키는 요소가 배열의 첫 번째 요소 `a[0][0]`이므로, `int`형 포인터라고 결론 내릴 수 있다.
		> 왜? 배열의 첫 번째 요소가 `int`형 변수이기 때문이다.
		- 하지만 이것이 끝이 아니고, 배열 이름 `a`의 포인터 타입은 조금 더 구체화되어야 한다.
			- 배열 이름 `a`가 '`int`형 포인터야'라고 하는 것은, 완벽한 설명이 아니다. 이 정도의 정의로는 하다 못해 배열 이름 `a`를 인자로 받는 함수조차 적절한 형태로 정의하지 못한다.
	- 자세한 내용은 [[배열의 이름과 포인터의 관계에 대해서#결론]]를 참조한다.
### 2) 2차원 배열 이름 + 1: 배열 이름을 이용한 포인터 연산
- 2차원 배열 이름도 배열의 첫 번째 요소를 가리키는 포인터이므로, 배열의 이름이 지니는 값을 하나 증가시키면 어딘가 새로운 곳을 가리키게 될 것이다.
#### `arr2_name.c`
```c
#include <stdio.h>

int main()
{
	int a[3][2] = {1, 2, 3, 4, 5, 6};

	printf("- a    : %p\n", a);
	printf("- a + 1: %p\n", a + 1);
	printf("- a + 2: %p\n", a + 2);

	return 0;
}

```
```
- a    : 0x107aa7740
- a + 1: 0x107aa7748
- a + 2: 0x107aa7750
```
- 2차원 배열 이름은 포인터 연산 시 행 단위로 이동을 한다.

### 3) 포인터의 타입에는 이동에 대한 정보가 들어있다.
- 우리가 흔히 이야기 하는 *포인터 타입*에는 *이동에 대한 정보*가 들어있다.

```c
#include <stdio.h>

int main()
{
	int a[5] = {1, 2, 3, 4, 5};
	double d[5] = {1.1, 2.2, 3.3, 4.4, 5.5};
	
	int * pA = a + 1; // +4 (a is int)
	int * pD = d + 1; // +8 (d is double)
	return 0;
}
```

- `a`에 $1$을 더하면 실제로는 $4$가 증가한다.
	- 피연산자 `a`가 `int *`형이기 때문이다.
- `d`에 $1$을 더하면 실제로는 $8$이 증가한다.
	- 피연산자 `d`가 `double *`형이기 때문이다.
- 실제로는 배열 이름이 해당 타입의 포인터로 [[배열의 이름과 포인터의 관계에 대해서#결론|붕괴]]한 것이다.
> 임의의 두 포인터 타입이 일치한다면, 기본적으로 포인터 연산에 의해 증가 및 감소되는 값의 크기가 일치해야 한다. 위 예제에서 `a`와 `d`는 연산에 의해 증가되는 값이 다르므로 둘은 서로 포인터 타입이 다르다고 말 할 수 있다.
```c
#include <stdio.h>

int main()
{
	int arr1[3][2];
	int arr2[2][3];

	printf("> About arr1[3][2]\n");
	printf("- arr1    : %p\n", arr1);
	printf("- arr1 + 1: %p\n", arr1 + 1);
	printf("- arr1 + 2: %p\n", arr1 + 2);

	printf("> About arr2[2][3]\n");
	printf("- arr2    : %p\n", arr2);
	printf("- arr2 + 1: %p\n", arr2 + 1);
	printf("- arr2 + 2: %p\n", arr2 + 2);

	return 0;
}

```
```
> About arr1[3][2]
- arr1    : 0x111076740
- arr1 + 1: 0x111076748
- arr1 + 2: 0x111076750
> About arr2[2][3]
- arr2    : 0x111076720
- arr2 + 1: 0x11107672c
- arr2 + 2: 0x111076738
```
- 결론적으로 `arr1`과 `arr2`는 배열 요소의 자료형이 같은 2차원 배열임에도 불구하고, 이름 자체가 지니는 포인터 타입은 다르다고 결론 내릴 수 있다. **왜냐하면 포인터 연산 시 증가되는 값이 차이를 보이기 때문이다.**
- `int arr1[3][2]`
	- 배열 이름 `arr1`은 `int`형 포인터이자, 포인터 연산 시 배열 요소를 $2$칸씩 건너 뛰는 포인터이다.
	- 이와 완전히 일치하는 타입의 포인터 변수는 `int (*pArr1)[2];`로 선언할 수 있다.
- `int arr2[2][3]`
	- 배열 이름 `arr2`은 `int`형 포인터이자, 포인터 연산 시 배열 요소를 $3$칸씩 건너 뛰는 포인터이다.
	- 이와 완전히 일치하는 타입의 포인터 변수는 `int (*pArr2)[3];`로 선언할 수 있다.
> 배열을 가리킬 수 있는 포인터를 **배열 포인터**라고 한다.

###### `pnt_arr.c`
```c
#include <stdio.h>

void show_data(int (*ptr)[4], int a);

int main()
{
	int arr1[2][4] = {1, 2, 3, 4, 5, 6, 7, 8};
	int arr2[3][4] = {{1}, {2}, {3}};

	show_data(arr1, 2);
	show_data(arr2, 3);

	return 0;
}

void show_data(int (*ptr)[4], int a)
{
	printf("======Start Printing======\n");
	for(int i = 0; i < a; i++)
	{
		for(int j = 0; j > 4; j++)
			printf("%d ", ptr[i][j]);
		printf("\n");
	}
	return;
}
```
- `arr1`과 `arr2`는 둘 다 `int`형 1차원 포인터이면서 포인터 연산시 $4$칸씩 이동을 한다.
	- 따라서 둘의 포인터 타입은 `int (*ptr)[4]`로 동일하다.
- 함수 `show_data`는 매개 변수로 `int (*ptr)[4]`를 전달받는다.
	- 함수의 매개 변수 선언 시 `int (*ptr)[4]`와 같은 표현 외에도 `int ptr[][4]`와 같은 표현도 사용 가능하다.
	- 이러한 표현은 함수의 매개 변수 선언시에만 가능하다. 외의 경우에 위같은 표현을 사용하면 크기를 생략한 배열 선언으로 인식한다.
#### `int (*pArr)[4]`와 `int * pArr[4]`의 차이점
- `int (*pArr)[4]`는 **포인터 배열**이다.
- `int * pArr[4]`는 **배열 포인터**이다.

